import { createChildLogger } from '../utils/logger.js';
import { rssiToDistance } from '../utils/frequency.js';
import { normalizeMac } from '../utils/mac.js';
import type { MeshNode, NetworkDevice } from '../types/network.js';
import type { DeviceLocation } from '../types/analysis.js';
import type { Building, FloorType, NodePlacement } from '../types/building.js';

const logger = createChildLogger('real-triangulation');

/**
 * True triangulation/trilateration engine using 3 mesh nodes.
 * 
 * With 3 nodes, we can perform proper geometric positioning:
 * - Trilateration: Using 3 distance measurements (from RSSI)
 * - Triangulation: Using angles between nodes (requires known node positions)
 * 
 * This implementation uses a hybrid approach:
 * 1. Convert RSSI to distance estimates
 * 2. Use geometric trilateration with 3 circles
 * 3. Apply Kalman-like smoothing for stability
 */

interface Position3D {
  x: number;
  y: number;
  z: number;
}

interface SignalMeasurement {
  nodeMac: string;
  nodePosition: Position3D;
  rssi: number;
  timestamp: Date;
}

interface TriangulatedPosition {
  deviceMac: string;
  deviceName: string;
  position: Position3D;
  floor: FloorType;
  floorNumber: number;
  confidence: number;
  method: 'trilateration' | 'bilateration' | 'single_node' | 'interpolated';
  lastUpdate: Date;
  signalReadings: Array<{
    nodeMac: string;
    nodeName: string;
    rssi: number;
    estimatedDistance: number;
  }>;
}

interface AutoGeneratedMap {
  id: string;
  generatedAt: Date;
  floors: Array<{
    floorNumber: number;
    floorType: FloorType;
    estimatedDimensions: {
      width: number;
      height: number;
      heightMeters: number;
    };
    nodePositions: Array<{
      nodeId: string;
      nodeMac: string;
      position: Position3D;
    }>;
    devicePositions: TriangulatedPosition[];
    bounds: {
      minX: number;
      maxX: number;
      minY: number;
      maxY: number;
    };
  }>;
  totalArea: number;
  confidence: number;
}

export interface HouseConfig {
  name: string;
  floors: Array<{
    floorNumber: number;
    floorType: FloorType;
    name: string;
    heightMeters: number;
    dimensions?: {
      widthMeters: number;
      lengthMeters: number;
    };
  }>;
  hasGarden: boolean;
  gardenDimensions?: {
    widthMeters: number;
    lengthMeters: number;
  };
  constructionType: 'wood_frame' | 'concrete' | 'brick' | 'mixed';
  wallThicknessCm: number;
}

export class RealTriangulationEngine {
  private nodePositions: Map<string, NodePlacement> = new Map();
  private signalHistory: Map<string, SignalMeasurement[]> = new Map();
  private positionCache: Map<string, TriangulatedPosition> = new Map();
  private houseConfig: HouseConfig | null = null;
  private building: Building | null = null;

  private readonly txPower: number = -59;
  private readonly pathLossExponent: number = 2.7;
  private readonly historyMaxAge: number = 60000; // 60 seconds
  private readonly historyMaxEntries: number = 100;

  setHouseConfig(config: HouseConfig): void {
    this.houseConfig = config;
    logger.info({ 
      name: config.name, 
      floors: config.floors.length,
      hasGarden: config.hasGarden 
    }, 'House configuration set');
  }

  getHouseConfig(): HouseConfig | null {
    return this.houseConfig;
  }

  setBuilding(building: Building): void {
    this.building = building;
  }

  setNodePosition(placement: NodePlacement): void {
    this.nodePositions.set(placement.nodeMac, placement);
    logger.info({ 
      nodeId: placement.nodeId, 
      floor: placement.floor,
      position: placement.position 
    }, 'Node position set');
  }

  setNodePositions(placements: NodePlacement[]): void {
    for (const p of placements) {
      this.setNodePosition(p);
    }
  }

  /**
   * Record a signal measurement for a device from a specific node
   */
  recordSignalMeasurement(
    deviceMac: string,
    nodeMac: string,
    rssi: number
  ): void {
    // Normalize MAC addresses for consistent lookup
    const normalizedNodeMac = normalizeMac(nodeMac);
    const normalizedDeviceMac = normalizeMac(deviceMac);
    
    const nodePos = this.nodePositions.get(normalizedNodeMac);
    if (!nodePos) {
      logger.warn({ nodeMac: normalizedNodeMac }, 'Signal recorded for unknown node position');
      return;
    }

    const measurement: SignalMeasurement = {
      nodeMac: normalizedNodeMac,
      nodePosition: nodePos.position,
      rssi,
      timestamp: new Date(),
    };

    const history = this.signalHistory.get(normalizedDeviceMac) ?? [];
    history.push(measurement);

    // Cleanup old entries
    const cutoff = Date.now() - this.historyMaxAge;
    const filtered = history
      .filter(m => m.timestamp.getTime() > cutoff)
      .slice(-this.historyMaxEntries);

    this.signalHistory.set(normalizedDeviceMac, filtered);
  }

  /**
   * Triangulate device position using available signal measurements
   */
  triangulateDevice(
    device: NetworkDevice,
    allNodes: MeshNode[]
  ): TriangulatedPosition | null {
    const measurements = this.collectMeasurements(device, allNodes);

    if (measurements.length === 0) {
      return null;
    }

    const signalReadings = measurements.map(m => {
      const node = allNodes.find(n => n.macAddress === m.nodeMac);
      return {
        nodeMac: m.nodeMac,
        nodeName: node?.name ?? m.nodeMac,
        rssi: m.rssi,
        estimatedDistance: this.rssiToDistance(m.rssi),
      };
    });

    let position: Position3D;
    let confidence: number;
    let method: TriangulatedPosition['method'];

    if (measurements.length >= 3) {
      // True trilateration with 3+ nodes
      const result = this.performTrilateration(measurements);
      position = result.position;
      confidence = result.confidence;
      method = 'trilateration';
    } else if (measurements.length === 2) {
      // Bilateration - intersection of two circles
      const result = this.performBilateration(measurements);
      position = result.position;
      confidence = result.confidence;
      method = 'bilateration';
    } else {
      // Single node - position at node with distance offset
      const m = measurements[0]!;
      const distance = this.rssiToDistance(m.rssi);
      position = {
        x: m.nodePosition.x,
        y: m.nodePosition.y,
        z: m.nodePosition.z,
      };
      confidence = 0.3;
      method = 'single_node';
    }

    // Determine floor
    const { floor, floorNumber } = this.determineFloor(position.z);

    // Apply smoothing with previous position
    const smoothed = this.applySmoothing(device.macAddress, position);

    const result: TriangulatedPosition = {
      deviceMac: device.macAddress,
      deviceName: device.hostname ?? device.macAddress,
      position: smoothed,
      floor,
      floorNumber,
      confidence,
      method,
      lastUpdate: new Date(),
      signalReadings,
    };

    this.positionCache.set(device.macAddress, result);
    return result;
  }

  /**
   * True trilateration using 3 distance measurements
   * Solves the intersection of 3 spheres
   */
  private performTrilateration(
    measurements: SignalMeasurement[]
  ): { position: Position3D; confidence: number } {
    // Sort by signal strength (strongest first = most reliable)
    const sorted = [...measurements].sort((a, b) => b.rssi - a.rssi);
    const m1 = sorted[0]!;
    const m2 = sorted[1]!;
    const m3 = sorted[2]!;

    const p1 = m1.nodePosition;
    const p2 = m2.nodePosition;
    const p3 = m3.nodePosition;

    const r1 = this.rssiToDistance(m1.rssi);
    const r2 = this.rssiToDistance(m2.rssi);
    const r3 = this.rssiToDistance(m3.rssi);

    // Transform to coordinate system where p1 is at origin
    const ex = this.normalize(this.subtract(p2, p1));
    const i = this.dot(ex, this.subtract(p3, p1));
    const ey_temp = this.subtract(this.subtract(p3, p1), this.scale(ex, i));
    const ey = this.normalize(ey_temp);
    const ez = this.cross(ex, ey);
    const d = this.distance3D(p1, p2);
    const j = this.dot(ey, this.subtract(p3, p1));

    // Solve for x, y
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const y = (r1 * r1 - r3 * r3 + i * i + j * j - 2 * i * x) / (2 * j);
    
    // Solve for z (may have two solutions)
    const zSquared = r1 * r1 - x * x - y * y;
    const z = zSquared > 0 ? Math.sqrt(zSquared) : 0;

    // Transform back to original coordinate system
    const result: Position3D = {
      x: p1.x + x * ex.x + y * ey.x + z * ez.x,
      y: p1.y + x * ex.y + y * ey.y + z * ez.y,
      z: p1.z + x * ex.z + y * ey.z + z * ez.z,
    };

    // Calculate confidence based on signal consistency
    const avgRssi = (m1.rssi + m2.rssi + m3.rssi) / 3;
    const rssiVariance = measurements.reduce((sum, m) => 
      sum + Math.pow(m.rssi - avgRssi, 2), 0) / measurements.length;
    
    // Higher variance = lower confidence
    const confidence = Math.max(0.5, Math.min(0.95, 1 - rssiVariance / 200));

    return { position: result, confidence };
  }

  /**
   * Bilateration using 2 distance measurements
   * Returns the midpoint of the two intersection points
   */
  private performBilateration(
    measurements: SignalMeasurement[]
  ): { position: Position3D; confidence: number } {
    const m1 = measurements[0]!;
    const m2 = measurements[1]!;

    const p1 = m1.nodePosition;
    const p2 = m2.nodePosition;

    const r1 = this.rssiToDistance(m1.rssi);
    const r2 = this.rssiToDistance(m2.rssi);

    const d = this.distance3D(p1, p2);

    // Check if circles intersect
    if (d > r1 + r2 || d < Math.abs(r1 - r2)) {
      // No intersection - return weighted average
      const w1 = 1 / r1;
      const w2 = 1 / r2;
      const total = w1 + w2;
      return {
        position: {
          x: (p1.x * w1 + p2.x * w2) / total,
          y: (p1.y * w1 + p2.y * w2) / total,
          z: (p1.z * w1 + p2.z * w2) / total,
        },
        confidence: 0.4,
      };
    }

    // Calculate intersection points
    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));

    // Point along line from p1 to p2
    const px = p1.x + a * (p2.x - p1.x) / d;
    const py = p1.y + a * (p2.y - p1.y) / d;
    const pz = p1.z + a * (p2.z - p1.z) / d;

    // Return the point on the line (midpoint of two solutions)
    return {
      position: { x: px, y: py, z: pz },
      confidence: 0.6,
    };
  }

  /**
   * Collect all available measurements for a device
   */
  private collectMeasurements(
    device: NetworkDevice,
    _allNodes: MeshNode[]
  ): SignalMeasurement[] {
    const measurements: SignalMeasurement[] = [];
    const now = Date.now();

    // Get recent history (use normalized MAC for consistent lookup)
    // Allow 10 minutes for persisted measurements across CLI calls
    const normalizedMac = normalizeMac(device.macAddress);
    const history = this.signalHistory.get(normalizedMac) ?? [];
    const recentHistory = history.filter(m => now - m.timestamp.getTime() < 600000);

    // Group by node and take average
    const byNode = new Map<string, SignalMeasurement[]>();
    for (const m of recentHistory) {
      const list = byNode.get(m.nodeMac) ?? [];
      list.push(m);
      byNode.set(m.nodeMac, list);
    }

    for (const [nodeMac, nodeHistory] of byNode) {
      const avgRssi = nodeHistory.reduce((s, m) => s + m.rssi, 0) / nodeHistory.length;
      const nodePos = this.nodePositions.get(nodeMac);
      if (nodePos) {
        measurements.push({
          nodeMac,
          nodePosition: nodePos.position,
          rssi: avgRssi,
          timestamp: new Date(),
        });
      }
    }

    // Add current connection if not already included
    if (device.signalStrength !== undefined && device.connectedToNode) {
      const existing = measurements.find(m => m.nodeMac === device.connectedToNode);
      if (!existing) {
        const nodePos = this.nodePositions.get(device.connectedToNode);
        if (nodePos) {
          measurements.push({
            nodeMac: device.connectedToNode,
            nodePosition: nodePos.position,
            rssi: device.signalStrength,
            timestamp: new Date(),
          });
        }
      }
    }

    return measurements;
  }

  /**
   * Apply exponential smoothing to reduce jitter
   */
  private applySmoothing(deviceMac: string, newPos: Position3D): Position3D {
    const cached = this.positionCache.get(deviceMac);
    if (!cached) return newPos;

    const alpha = 0.3; // Smoothing factor
    return {
      x: alpha * newPos.x + (1 - alpha) * cached.position.x,
      y: alpha * newPos.y + (1 - alpha) * cached.position.y,
      z: alpha * newPos.z + (1 - alpha) * cached.position.z,
    };
  }

  /**
   * Determine floor based on Z coordinate
   */
  private determineFloor(z: number): { floor: FloorType; floorNumber: number } {
    if (this.houseConfig) {
      // Use house config floor heights
      let accumulatedHeight = 0;
      for (const floor of this.houseConfig.floors) {
        accumulatedHeight += floor.heightMeters;
        if (z < accumulatedHeight) {
          return { floor: floor.floorType, floorNumber: floor.floorNumber };
        }
      }
    }

    // Default floor detection
    if (z < 0) return { floor: 'basement', floorNumber: -1 };
    if (z < 3) return { floor: 'ground', floorNumber: 0 };
    if (z < 6) return { floor: 'first', floorNumber: 1 };
    if (z < 9) return { floor: 'second', floorNumber: 2 };
    if (z < 12) return { floor: 'third', floorNumber: 3 };
    return { floor: 'attic', floorNumber: 4 };
  }

  /**
   * Auto-generate a map from device and node positions
   * Works without floor plans or images
   */
  generateAutoMap(
    nodes: MeshNode[],
    devices: NetworkDevice[]
  ): AutoGeneratedMap {
    // First, triangulate all devices
    const triangulatedDevices: TriangulatedPosition[] = [];
    for (const device of devices) {
      const pos = this.triangulateDevice(device, nodes);
      if (pos) {
        triangulatedDevices.push(pos);
      }
    }

    // Group by floor
    const floorGroups = new Map<number, TriangulatedPosition[]>();
    for (const device of triangulatedDevices) {
      const list = floorGroups.get(device.floorNumber) ?? [];
      list.push(device);
      floorGroups.set(device.floorNumber, list);
    }

    // Calculate bounds for each floor
    const floors: AutoGeneratedMap['floors'] = [];
    
    for (const [floorNumber, floorDevices] of floorGroups) {
      // Get node positions on this floor
      const floorNodes = Array.from(this.nodePositions.values())
        .filter(n => n.floorNumber === floorNumber);

      // Calculate bounds from all positions
      const allPositions = [
        ...floorDevices.map(d => d.position),
        ...floorNodes.map(n => n.position),
      ];

      if (allPositions.length === 0) continue;

      const minX = Math.min(...allPositions.map(p => p.x)) - 2;
      const maxX = Math.max(...allPositions.map(p => p.x)) + 2;
      const minY = Math.min(...allPositions.map(p => p.y)) - 2;
      const maxY = Math.max(...allPositions.map(p => p.y)) + 2;

      const width = maxX - minX;
      const height = maxY - minY;

      const floorType = this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.floorType
        ?? this.determineFloor(floorNumber * 3).floor;

      floors.push({
        floorNumber,
        floorType,
        estimatedDimensions: {
          width,
          height,
          heightMeters: this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.heightMeters ?? 2.8,
        },
        nodePositions: floorNodes.map(n => ({
          nodeId: n.nodeId,
          nodeMac: n.nodeMac,
          position: n.position,
        })),
        devicePositions: floorDevices,
        bounds: { minX, maxX, minY, maxY },
      });
    }

    // Calculate total area
    const totalArea = floors.reduce((sum, f) => 
      sum + f.estimatedDimensions.width * f.estimatedDimensions.height, 0);

    // Overall confidence
    const avgConfidence = triangulatedDevices.length > 0
      ? triangulatedDevices.reduce((s, d) => s + d.confidence, 0) / triangulatedDevices.length
      : 0;

    return {
      id: `map_${Date.now()}`,
      generatedAt: new Date(),
      floors: floors.sort((a, b) => a.floorNumber - b.floorNumber),
      totalArea,
      confidence: avgConfidence,
    };
  }

  /**
   * Generate ASCII visualization of a floor
   */
  generateFloorAscii(floorNumber: number): string {
    const cached = Array.from(this.positionCache.values())
      .filter(p => p.floorNumber === floorNumber);
    
    const nodes = Array.from(this.nodePositions.values())
      .filter(n => n.floorNumber === floorNumber);

    if (cached.length === 0 && nodes.length === 0) {
      return `Keine Daten für Etage ${floorNumber}`;
    }

    // Calculate bounds
    const allX = [...cached.map(c => c.position.x), ...nodes.map(n => n.position.x)];
    const allY = [...cached.map(c => c.position.y), ...nodes.map(n => n.position.y)];
    
    const minX = Math.min(...allX) - 1;
    const maxX = Math.max(...allX) + 1;
    const minY = Math.min(...allY) - 1;
    const maxY = Math.max(...allY) + 1;

    const width = 60;
    const height = 30;
    const scaleX = width / (maxX - minX);
    const scaleY = height / (maxY - minY);

    // Create grid
    const grid: string[][] = Array(height).fill(null).map(() => Array(width).fill('·'));

    // Place nodes
    for (const node of nodes) {
      const x = Math.round((node.position.x - minX) * scaleX);
      const y = Math.round((node.position.y - minY) * scaleY);
      if (x >= 0 && x < width && y >= 0 && y < height) {
        grid[y]![x] = '◉';
      }
    }

    // Place devices
    for (const device of cached) {
      const x = Math.round((device.position.x - minX) * scaleX);
      const y = Math.round((device.position.y - minY) * scaleY);
      if (x >= 0 && x < width && y >= 0 && y < height) {
        const symbol = device.confidence > 0.7 ? '●' :
                       device.confidence > 0.5 ? '◐' :
                       device.confidence > 0.3 ? '◔' : '○';
        if (grid[y]![x] === '·') {
          grid[y]![x] = symbol;
        }
      }
    }

    // Build output
    const floorName = this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.name 
      ?? `Etage ${floorNumber}`;
    
    let ascii = `┌${'─'.repeat(width)}┐\n`;
    ascii += `│ ${floorName.padEnd(width - 2)} │\n`;
    ascii += `│ Nodes: ${nodes.length}, Devices: ${cached.length}${' '.repeat(width - 22 - String(nodes.length).length - String(cached.length).length)}│\n`;
    ascii += `├${'─'.repeat(width)}┤\n`;
    
    for (const row of grid) {
      ascii += `│${row.join('')}│\n`;
    }
    
    ascii += `├${'─'.repeat(width)}┤\n`;
    ascii += `│ ◉=Node ●=High ◐=Medium ◔=Low ○=VeryLow Confidence ${' '.repeat(width - 52)}│\n`;
    ascii += `└${'─'.repeat(width)}┘`;
    
    return ascii;
  }

  // Vector math helpers
  private rssiToDistance(rssi: number): number {
    const ratio = (this.txPower - rssi) / (10 * this.pathLossExponent);
    return Math.pow(10, ratio);
  }

  private subtract(a: Position3D, b: Position3D): Position3D {
    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
  }

  private scale(v: Position3D, s: number): Position3D {
    return { x: v.x * s, y: v.y * s, z: v.z * s };
  }

  private dot(a: Position3D, b: Position3D): number {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  }

  private cross(a: Position3D, b: Position3D): Position3D {
    return {
      x: a.y * b.z - a.z * b.y,
      y: a.z * b.x - a.x * b.z,
      z: a.x * b.y - a.y * b.x,
    };
  }

  private magnitude(v: Position3D): number {
    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
  }

  private normalize(v: Position3D): Position3D {
    const m = this.magnitude(v);
    if (m === 0) return { x: 0, y: 0, z: 0 };
    return { x: v.x / m, y: v.y / m, z: v.z / m };
  }

  private distance3D(a: Position3D, b: Position3D): number {
    return this.magnitude(this.subtract(a, b));
  }

  // Getters
  getNodePositions(): NodePlacement[] {
    return Array.from(this.nodePositions.values());
  }

  getCachedPositions(): TriangulatedPosition[] {
    return Array.from(this.positionCache.values());
  }

  clearCache(): void {
    this.positionCache.clear();
    this.signalHistory.clear();
  }

  /**
   * Export signal measurements for persistence
   */
  exportSignalMeasurements(): Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>> {
    const result: Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>> = {};
    
    for (const [deviceMac, measurements] of this.signalHistory) {
      result[deviceMac] = measurements.map(m => ({
        nodeMac: m.nodeMac,
        rssi: m.rssi,
        timestamp: m.timestamp.toISOString(),
      }));
    }
    
    return result;
  }

  /**
   * Import signal measurements from persisted state
   */
  importSignalMeasurements(data: Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>>): void {
    for (const [deviceMac, measurements] of Object.entries(data)) {
      for (const m of measurements) {
        const nodePos = this.nodePositions.get(m.nodeMac);
        if (nodePos) {
          const history = this.signalHistory.get(deviceMac) ?? [];
          history.push({
            nodeMac: m.nodeMac,
            nodePosition: nodePos.position,
            rssi: m.rssi,
            timestamp: new Date(m.timestamp),
          });
          this.signalHistory.set(deviceMac, history);
        }
      }
    }
    
    logger.info({ deviceCount: Object.keys(data).length }, 'Signal measurements imported');
  }

  /**
   * Get signal measurement count for diagnostics
   */
  getSignalMeasurementCount(): { devices: number; measurements: number } {
    let measurements = 0;
    for (const history of this.signalHistory.values()) {
      measurements += history.length;
    }
    return { devices: this.signalHistory.size, measurements };
  }
}
