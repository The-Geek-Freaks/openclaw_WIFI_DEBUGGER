import { createChildLogger } from '../utils/logger.js';
import { rssiToDistance } from '../utils/frequency.js';
import { normalizeMac } from '../utils/mac.js';
import type { MeshNode, NetworkDevice } from '../types/network.js';
import type { ZigbeeDevice } from '../types/zigbee.js';
import type { DeviceLocation } from '../types/analysis.js';
import type { Building, FloorType, NodePlacement } from '../types/building.js';

const logger = createChildLogger('real-triangulation');

/**
 * True triangulation/trilateration engine using 3 mesh nodes.
 * 
 * With 3 nodes, we can perform proper geometric positioning:
 * - Trilateration: Using 3 distance measurements (from RSSI)
 * - Triangulation: Using angles between nodes (requires known node positions)
 * 
 * This implementation uses a hybrid approach:
 * 1. Convert RSSI to distance estimates
 * 2. Use geometric trilateration with 3 circles
 * 3. Apply Kalman-like smoothing for stability
 */

interface Position3D {
  x: number;
  y: number;
  z: number;
}

interface SignalMeasurement {
  nodeMac: string;
  nodePosition: Position3D;
  rssi: number;
  timestamp: Date;
}

interface TriangulatedPosition {
  deviceMac: string;
  deviceName: string;
  position: Position3D;
  floor: FloorType;
  floorNumber: number;
  confidence: number;
  method: 'trilateration' | 'bilateration' | 'single_node' | 'interpolated';
  lastUpdate: Date;
  signalReadings: Array<{
    nodeMac: string;
    nodeName: string;
    rssi: number;
    estimatedDistance: number;
  }>;
}

interface ZigbeePosition {
  ieeeAddress: string;
  friendlyName: string;
  type: 'coordinator' | 'router' | 'end_device';
  position: Position3D;
  floor: FloorType;
  floorNumber: number;
  lqi: number;
  estimatedDistance: number;
  positionMethod: 'coordinator_relative' | 'router_relative' | 'estimated';
}

interface AutoGeneratedMap {
  id: string;
  generatedAt: Date;
  floors: Array<{
    floorNumber: number;
    floorType: FloorType;
    estimatedDimensions: {
      width: number;
      height: number;
      heightMeters: number;
    };
    nodePositions: Array<{
      nodeId: string;
      nodeMac: string;
      position: Position3D;
    }>;
    devicePositions: TriangulatedPosition[];
    zigbeePositions: ZigbeePosition[];
    bounds: {
      minX: number;
      maxX: number;
      minY: number;
      maxY: number;
    };
  }>;
  totalArea: number;
  confidence: number;
}

export interface HouseConfig {
  name: string;
  floors: Array<{
    floorNumber: number;
    floorType: FloorType;
    name: string;
    heightMeters: number;
    dimensions?: {
      widthMeters: number;
      lengthMeters: number;
    };
  }>;
  hasGarden: boolean;
  gardenDimensions?: {
    widthMeters: number;
    lengthMeters: number;
  };
  constructionType: 'wood_frame' | 'concrete' | 'brick' | 'mixed';
  wallThicknessCm: number;
}

export class RealTriangulationEngine {
  private nodePositions: Map<string, NodePlacement> = new Map();
  private signalHistory: Map<string, SignalMeasurement[]> = new Map();
  private positionCache: Map<string, TriangulatedPosition> = new Map();
  private houseConfig: HouseConfig | null = null;
  private building: Building | null = null;

  private readonly txPower: number = -59;
  private readonly pathLossExponent: number = 2.7;
  private readonly historyMaxAge: number = 60000; // 60 seconds
  private readonly historyMaxEntries: number = 100;

  setHouseConfig(config: HouseConfig): void {
    this.houseConfig = config;
    logger.info({ 
      name: config.name, 
      floors: config.floors.length,
      hasGarden: config.hasGarden 
    }, 'House configuration set');
  }

  getHouseConfig(): HouseConfig | null {
    return this.houseConfig;
  }

  setBuilding(building: Building): void {
    this.building = building;
  }

  setNodePosition(placement: NodePlacement): void {
    this.nodePositions.set(placement.nodeMac, placement);
    logger.info({ 
      nodeId: placement.nodeId, 
      floor: placement.floor,
      position: placement.position 
    }, 'Node position set');
  }

  setNodePositions(placements: NodePlacement[]): void {
    for (const p of placements) {
      this.setNodePosition(p);
    }
  }

  /**
   * Record a signal measurement for a device from a specific node
   */
  recordSignalMeasurement(
    deviceMac: string,
    nodeMac: string,
    rssi: number
  ): void {
    // Normalize MAC addresses for consistent lookup
    const normalizedNodeMac = normalizeMac(nodeMac);
    const normalizedDeviceMac = normalizeMac(deviceMac);
    
    const nodePos = this.nodePositions.get(normalizedNodeMac);
    if (!nodePos) {
      logger.warn({ nodeMac: normalizedNodeMac }, 'Signal recorded for unknown node position');
      return;
    }

    const measurement: SignalMeasurement = {
      nodeMac: normalizedNodeMac,
      nodePosition: nodePos.position,
      rssi,
      timestamp: new Date(),
    };

    const history = this.signalHistory.get(normalizedDeviceMac) ?? [];
    history.push(measurement);

    // Cleanup old entries
    const cutoff = Date.now() - this.historyMaxAge;
    const filtered = history
      .filter(m => m.timestamp.getTime() > cutoff)
      .slice(-this.historyMaxEntries);

    this.signalHistory.set(normalizedDeviceMac, filtered);
  }

  /**
   * Triangulate device position using available signal measurements
   */
  triangulateDevice(
    device: NetworkDevice,
    allNodes: MeshNode[]
  ): TriangulatedPosition | null {
    const measurements = this.collectMeasurements(device, allNodes);

    if (measurements.length === 0) {
      return null;
    }

    const signalReadings = measurements.map(m => {
      const node = allNodes.find(n => n.macAddress === m.nodeMac);
      return {
        nodeMac: m.nodeMac,
        nodeName: node?.name ?? m.nodeMac,
        rssi: m.rssi,
        estimatedDistance: this.rssiToDistance(m.rssi),
      };
    });

    let position: Position3D;
    let confidence: number;
    let method: TriangulatedPosition['method'];

    if (measurements.length >= 3) {
      // True trilateration with 3+ nodes
      const result = this.performTrilateration(measurements);
      position = result.position;
      confidence = result.confidence;
      method = 'trilateration';
    } else if (measurements.length === 2) {
      // Bilateration - intersection of two circles
      const result = this.performBilateration(measurements);
      position = result.position;
      confidence = result.confidence;
      method = 'bilateration';
    } else {
      // Single node - position at node with distance offset
      const m = measurements[0]!;
      const distance = this.rssiToDistance(m.rssi);
      position = {
        x: m.nodePosition.x,
        y: m.nodePosition.y,
        z: m.nodePosition.z,
      };
      confidence = 0.3;
      method = 'single_node';
    }

    // Determine floor
    const { floor, floorNumber } = this.determineFloor(position.z);

    // Apply smoothing with previous position
    const smoothed = this.applySmoothing(device.macAddress, position);

    const result: TriangulatedPosition = {
      deviceMac: device.macAddress,
      deviceName: device.hostname ?? device.macAddress,
      position: smoothed,
      floor,
      floorNumber,
      confidence,
      method,
      lastUpdate: new Date(),
      signalReadings,
    };

    this.positionCache.set(device.macAddress, result);
    return result;
  }

  /**
   * True trilateration using 3 distance measurements
   * Solves the intersection of 3 spheres
   */
  private performTrilateration(
    measurements: SignalMeasurement[]
  ): { position: Position3D; confidence: number } {
    // Sort by signal strength (strongest first = most reliable)
    const sorted = [...measurements].sort((a, b) => b.rssi - a.rssi);
    const m1 = sorted[0]!;
    const m2 = sorted[1]!;
    const m3 = sorted[2]!;

    const p1 = m1.nodePosition;
    const p2 = m2.nodePosition;
    const p3 = m3.nodePosition;

    const r1 = this.rssiToDistance(m1.rssi);
    const r2 = this.rssiToDistance(m2.rssi);
    const r3 = this.rssiToDistance(m3.rssi);

    // Transform to coordinate system where p1 is at origin
    const ex = this.normalize(this.subtract(p2, p1));
    const i = this.dot(ex, this.subtract(p3, p1));
    const ey_temp = this.subtract(this.subtract(p3, p1), this.scale(ex, i));
    const ey = this.normalize(ey_temp);
    const ez = this.cross(ex, ey);
    const d = this.distance3D(p1, p2);
    const j = this.dot(ey, this.subtract(p3, p1));

    // Solve for x, y
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const y = (r1 * r1 - r3 * r3 + i * i + j * j - 2 * i * x) / (2 * j);
    
    // Solve for z (may have two solutions)
    const zSquared = r1 * r1 - x * x - y * y;
    const z = zSquared > 0 ? Math.sqrt(zSquared) : 0;

    // Transform back to original coordinate system
    const result: Position3D = {
      x: p1.x + x * ex.x + y * ey.x + z * ez.x,
      y: p1.y + x * ex.y + y * ey.y + z * ez.y,
      z: p1.z + x * ex.z + y * ey.z + z * ez.z,
    };

    // Calculate confidence based on signal consistency
    const avgRssi = (m1.rssi + m2.rssi + m3.rssi) / 3;
    const rssiVariance = measurements.reduce((sum, m) => 
      sum + Math.pow(m.rssi - avgRssi, 2), 0) / measurements.length;
    
    // Higher variance = lower confidence
    const confidence = Math.max(0.5, Math.min(0.95, 1 - rssiVariance / 200));

    return { position: result, confidence };
  }

  /**
   * Bilateration using 2 distance measurements
   * Returns the midpoint of the two intersection points
   */
  private performBilateration(
    measurements: SignalMeasurement[]
  ): { position: Position3D; confidence: number } {
    const m1 = measurements[0]!;
    const m2 = measurements[1]!;

    const p1 = m1.nodePosition;
    const p2 = m2.nodePosition;

    const r1 = this.rssiToDistance(m1.rssi);
    const r2 = this.rssiToDistance(m2.rssi);

    const d = this.distance3D(p1, p2);

    // Check if circles intersect
    if (d > r1 + r2 || d < Math.abs(r1 - r2)) {
      // No intersection - return weighted average
      const w1 = 1 / r1;
      const w2 = 1 / r2;
      const total = w1 + w2;
      return {
        position: {
          x: (p1.x * w1 + p2.x * w2) / total,
          y: (p1.y * w1 + p2.y * w2) / total,
          z: (p1.z * w1 + p2.z * w2) / total,
        },
        confidence: 0.4,
      };
    }

    // Calculate intersection points
    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));

    // Point along line from p1 to p2
    const px = p1.x + a * (p2.x - p1.x) / d;
    const py = p1.y + a * (p2.y - p1.y) / d;
    const pz = p1.z + a * (p2.z - p1.z) / d;

    // Return the point on the line (midpoint of two solutions)
    return {
      position: { x: px, y: py, z: pz },
      confidence: 0.6,
    };
  }

  /**
   * Collect all available measurements for a device
   */
  private collectMeasurements(
    device: NetworkDevice,
    _allNodes: MeshNode[]
  ): SignalMeasurement[] {
    const measurements: SignalMeasurement[] = [];
    const now = Date.now();

    // Get recent history (use normalized MAC for consistent lookup)
    // Allow 10 minutes for persisted measurements across CLI calls
    const normalizedMac = normalizeMac(device.macAddress);
    const history = this.signalHistory.get(normalizedMac) ?? [];
    const recentHistory = history.filter(m => now - m.timestamp.getTime() < 600000);

    // Group by node and take average
    const byNode = new Map<string, SignalMeasurement[]>();
    for (const m of recentHistory) {
      const list = byNode.get(m.nodeMac) ?? [];
      list.push(m);
      byNode.set(m.nodeMac, list);
    }

    for (const [nodeMac, nodeHistory] of byNode) {
      const avgRssi = nodeHistory.reduce((s, m) => s + m.rssi, 0) / nodeHistory.length;
      const nodePos = this.nodePositions.get(nodeMac);
      if (nodePos) {
        measurements.push({
          nodeMac,
          nodePosition: nodePos.position,
          rssi: avgRssi,
          timestamp: new Date(),
        });
      }
    }

    // Add current connection if not already included
    if (device.signalStrength !== undefined && device.connectedToNode) {
      const existing = measurements.find(m => m.nodeMac === device.connectedToNode);
      if (!existing) {
        const nodePos = this.nodePositions.get(device.connectedToNode);
        if (nodePos) {
          measurements.push({
            nodeMac: device.connectedToNode,
            nodePosition: nodePos.position,
            rssi: device.signalStrength,
            timestamp: new Date(),
          });
        }
      }
    }

    return measurements;
  }

  /**
   * Apply exponential smoothing to reduce jitter
   */
  private applySmoothing(deviceMac: string, newPos: Position3D): Position3D {
    const cached = this.positionCache.get(deviceMac);
    if (!cached) return newPos;

    const alpha = 0.3; // Smoothing factor
    return {
      x: alpha * newPos.x + (1 - alpha) * cached.position.x,
      y: alpha * newPos.y + (1 - alpha) * cached.position.y,
      z: alpha * newPos.z + (1 - alpha) * cached.position.z,
    };
  }

  /**
   * Determine floor based on Z coordinate
   */
  private determineFloor(z: number): { floor: FloorType; floorNumber: number } {
    if (this.houseConfig) {
      // Use house config floor heights
      let accumulatedHeight = 0;
      for (const floor of this.houseConfig.floors) {
        accumulatedHeight += floor.heightMeters;
        if (z < accumulatedHeight) {
          return { floor: floor.floorType, floorNumber: floor.floorNumber };
        }
      }
    }

    // Default floor detection
    if (z < 0) return { floor: 'basement', floorNumber: -1 };
    if (z < 3) return { floor: 'ground', floorNumber: 0 };
    if (z < 6) return { floor: 'first', floorNumber: 1 };
    if (z < 9) return { floor: 'second', floorNumber: 2 };
    if (z < 12) return { floor: 'third', floorNumber: 3 };
    return { floor: 'attic', floorNumber: 4 };
  }

  /**
   * Auto-generate a map from device and node positions
   * Works without floor plans or images
   * Now supports Zigbee devices on the same map
   */
  generateAutoMap(
    nodes: MeshNode[],
    devices: NetworkDevice[],
    zigbeeDevices?: ZigbeeDevice[]
  ): AutoGeneratedMap {
    // First, triangulate all devices
    const triangulatedDevices: TriangulatedPosition[] = [];
    for (const device of devices) {
      const pos = this.triangulateDevice(device, nodes);
      if (pos) {
        triangulatedDevices.push(pos);
      }
    }

    // Group by floor
    const floorGroups = new Map<number, TriangulatedPosition[]>();
    for (const device of triangulatedDevices) {
      const list = floorGroups.get(device.floorNumber) ?? [];
      list.push(device);
      floorGroups.set(device.floorNumber, list);
    }

    // Calculate bounds for each floor
    const floors: AutoGeneratedMap['floors'] = [];
    
    for (const [floorNumber, floorDevices] of floorGroups) {
      // Get node positions on this floor
      const floorNodes = Array.from(this.nodePositions.values())
        .filter(n => n.floorNumber === floorNumber);

      // Calculate bounds from all positions
      const allPositions = [
        ...floorDevices.map(d => d.position),
        ...floorNodes.map(n => n.position),
      ];

      if (allPositions.length === 0) continue;

      const minX = Math.min(...allPositions.map(p => p.x)) - 2;
      const maxX = Math.max(...allPositions.map(p => p.x)) + 2;
      const minY = Math.min(...allPositions.map(p => p.y)) - 2;
      const maxY = Math.max(...allPositions.map(p => p.y)) + 2;

      const width = maxX - minX;
      const height = maxY - minY;

      const floorType = this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.floorType
        ?? this.determineFloor(floorNumber * 3).floor;

      floors.push({
        floorNumber,
        floorType,
        estimatedDimensions: {
          width,
          height,
          heightMeters: this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.heightMeters ?? 2.8,
        },
        nodePositions: floorNodes.map(n => ({
          nodeId: n.nodeId,
          nodeMac: n.nodeMac,
          position: n.position,
        })),
        devicePositions: floorDevices,
        zigbeePositions: [], // Will be populated when zigbeeDevices are passed
        bounds: { minX, maxX, minY, maxY },
      });
    }

    // Position Zigbee devices if provided
    if (zigbeeDevices && zigbeeDevices.length > 0) {
      const zigbeePositions = this.positionZigbeeDevices(zigbeeDevices);
      
      // Add Zigbee positions to appropriate floors
      for (const zPos of zigbeePositions) {
        const floor = floors.find(f => f.floorNumber === zPos.floorNumber);
        if (floor) {
          floor.zigbeePositions.push(zPos);
          // Update bounds to include Zigbee devices
          floor.bounds.minX = Math.min(floor.bounds.minX, zPos.position.x - 1);
          floor.bounds.maxX = Math.max(floor.bounds.maxX, zPos.position.x + 1);
          floor.bounds.minY = Math.min(floor.bounds.minY, zPos.position.y - 1);
          floor.bounds.maxY = Math.max(floor.bounds.maxY, zPos.position.y + 1);
        } else if (floors.length > 0) {
          // Add to ground floor if no matching floor
          const groundFloor = floors.find(f => f.floorNumber === 0) ?? floors[0];
          if (groundFloor) {
            groundFloor.zigbeePositions.push(zPos);
          }
        }
      }
    }

    // Calculate total area
    const totalArea = floors.reduce((sum, f) => 
      sum + f.estimatedDimensions.width * f.estimatedDimensions.height, 0);

    // Overall confidence
    const avgConfidence = triangulatedDevices.length > 0
      ? triangulatedDevices.reduce((s, d) => s + d.confidence, 0) / triangulatedDevices.length
      : 0;

    return {
      id: `map_${Date.now()}`,
      generatedAt: new Date(),
      floors: floors.sort((a, b) => a.floorNumber - b.floorNumber),
      totalArea,
      confidence: avgConfidence,
    };
  }

  /**
   * Position Zigbee devices on the map based on LQI and device type.
   * Coordinator is placed at a reference position, routers around it,
   * and end devices around their nearest router.
   */
  private positionZigbeeDevices(devices: ZigbeeDevice[]): ZigbeePosition[] {
    const positions: ZigbeePosition[] = [];
    
    // Find coordinator and use first node position as reference
    const coordinator = devices.find(d => d.type === 'coordinator');
    const routers = devices.filter(d => d.type === 'router');
    const endDevices = devices.filter(d => d.type === 'end_device');
    
    // Get reference position from first mesh node or use center
    const nodePositions = Array.from(this.nodePositions.values());
    const referencePos: Position3D = nodePositions.length > 0
      ? { ...nodePositions[0]!.position }
      : { x: 5, y: 5, z: 0 };
    
    // Position coordinator at reference
    if (coordinator) {
      positions.push({
        ieeeAddress: coordinator.ieeeAddress,
        friendlyName: coordinator.friendlyName ?? 'Coordinator',
        type: 'coordinator',
        position: { ...referencePos },
        floor: 'ground',
        floorNumber: 0,
        lqi: 255,
        estimatedDistance: 0,
        positionMethod: 'coordinator_relative',
      });
    }
    
    // Position routers in a circle around coordinator based on LQI
    const routerAngleStep = (2 * Math.PI) / Math.max(routers.length, 1);
    routers.forEach((router, i) => {
      const lqi = router.lqi ?? 100;
      const distance = this.lqiToDistance(lqi);
      const angle = i * routerAngleStep;
      
      positions.push({
        ieeeAddress: router.ieeeAddress,
        friendlyName: router.friendlyName ?? router.ieeeAddress,
        type: 'router',
        position: {
          x: referencePos.x + Math.cos(angle) * distance,
          y: referencePos.y + Math.sin(angle) * distance,
          z: referencePos.z,
        },
        floor: 'ground',
        floorNumber: 0,
        lqi,
        estimatedDistance: distance,
        positionMethod: 'coordinator_relative',
      });
    });
    
    // Position end devices around their nearest router (or coordinator)
    const routerPositions = positions.filter(p => p.type === 'router' || p.type === 'coordinator');
    const endDeviceAngleStep = (2 * Math.PI) / Math.max(endDevices.length, 1);
    
    endDevices.forEach((device, i) => {
      const lqi = device.lqi ?? 50;
      const distance = this.lqiToDistance(lqi) * 0.5; // Closer to router
      const angle = i * endDeviceAngleStep + Math.PI / 4; // Offset angle
      
      // Find nearest router based on LQI (higher LQI = closer)
      const nearestRouter = routerPositions.length > 0
        ? routerPositions.reduce((best, r) => r.lqi > best.lqi ? r : best, routerPositions[0]!)
        : { position: referencePos, type: 'coordinator' as const };
      
      positions.push({
        ieeeAddress: device.ieeeAddress,
        friendlyName: device.friendlyName ?? device.ieeeAddress,
        type: 'end_device',
        position: {
          x: nearestRouter.position.x + Math.cos(angle) * distance,
          y: nearestRouter.position.y + Math.sin(angle) * distance,
          z: nearestRouter.position.z,
        },
        floor: 'ground',
        floorNumber: 0,
        lqi,
        estimatedDistance: distance,
        positionMethod: nearestRouter.type === 'coordinator' ? 'coordinator_relative' : 'router_relative',
      });
    });
    
    return positions;
  }

  /**
   * Convert LQI (0-255) to estimated distance in meters.
   * LQI 255 = ~0m, LQI 0 = ~30m
   */
  private lqiToDistance(lqi: number): number {
    const normalizedLqi = Math.max(0, Math.min(255, lqi));
    const maxDistance = 15; // meters
    return maxDistance * (1 - normalizedLqi / 255);
  }

  /**
   * Generate ASCII visualization of a floor
   */
  generateFloorAscii(floorNumber: number): string {
    const cached = Array.from(this.positionCache.values())
      .filter(p => p.floorNumber === floorNumber);
    
    const nodes = Array.from(this.nodePositions.values())
      .filter(n => n.floorNumber === floorNumber);

    if (cached.length === 0 && nodes.length === 0) {
      return `Keine Daten f√ºr Etage ${floorNumber}`;
    }

    // Calculate bounds
    const allX = [...cached.map(c => c.position.x), ...nodes.map(n => n.position.x)];
    const allY = [...cached.map(c => c.position.y), ...nodes.map(n => n.position.y)];
    
    const minX = Math.min(...allX) - 1;
    const maxX = Math.max(...allX) + 1;
    const minY = Math.min(...allY) - 1;
    const maxY = Math.max(...allY) + 1;

    const width = 60;
    const height = 30;
    const scaleX = width / (maxX - minX);
    const scaleY = height / (maxY - minY);

    // Create grid
    const grid: string[][] = Array(height).fill(null).map(() => Array(width).fill('¬∑'));

    // Place nodes
    for (const node of nodes) {
      const x = Math.round((node.position.x - minX) * scaleX);
      const y = Math.round((node.position.y - minY) * scaleY);
      if (x >= 0 && x < width && y >= 0 && y < height) {
        grid[y]![x] = '‚óâ';
      }
    }

    // Place devices
    for (const device of cached) {
      const x = Math.round((device.position.x - minX) * scaleX);
      const y = Math.round((device.position.y - minY) * scaleY);
      if (x >= 0 && x < width && y >= 0 && y < height) {
        const symbol = device.confidence > 0.7 ? '‚óè' :
                       device.confidence > 0.5 ? '‚óê' :
                       device.confidence > 0.3 ? '‚óî' : '‚óã';
        if (grid[y]![x] === '¬∑') {
          grid[y]![x] = symbol;
        }
      }
    }

    // Build output
    const floorName = this.houseConfig?.floors.find(f => f.floorNumber === floorNumber)?.name 
      ?? `Etage ${floorNumber}`;
    
    let ascii = `‚îå${'‚îÄ'.repeat(width)}‚îê\n`;
    ascii += `‚îÇ ${floorName.padEnd(width - 2)} ‚îÇ\n`;
    ascii += `‚îÇ Nodes: ${nodes.length}, Devices: ${cached.length}${' '.repeat(width - 22 - String(nodes.length).length - String(cached.length).length)}‚îÇ\n`;
    ascii += `‚îú${'‚îÄ'.repeat(width)}‚î§\n`;
    
    for (const row of grid) {
      ascii += `‚îÇ${row.join('')}‚îÇ\n`;
    }
    
    ascii += `‚îú${'‚îÄ'.repeat(width)}‚î§\n`;
    ascii += `‚îÇ ‚óâ=Node ‚óè=High ‚óê=Medium ‚óî=Low ‚óã=VeryLow Confidence ${' '.repeat(width - 52)}‚îÇ\n`;
    ascii += `‚îî${'‚îÄ'.repeat(width)}‚îò`;
    
    return ascii;
  }

  /**
   * Generate SVG map of all floors with nodes and devices
   * Works without floor plan images - creates pure vector graphics
   */
  generateSvgMap(floorNumber?: number): string {
    const floors = floorNumber !== undefined 
      ? [floorNumber] 
      : [...new Set([
          ...Array.from(this.nodePositions.values()).map(n => n.floorNumber),
          ...Array.from(this.positionCache.values()).map(p => p.floorNumber),
        ])].sort();

    if (floors.length === 0) {
      return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 200"><text x="200" y="100" text-anchor="middle" font-family="sans-serif">Keine Daten verf√ºgbar</text></svg>';
    }

    const svgWidth = 800;
    const floorHeight = 400;
    const padding = 40;
    const totalHeight = floors.length * floorHeight;

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${totalHeight}" width="${svgWidth}" height="${totalHeight}">\n`;
    svg += `  <defs>\n`;
    svg += `    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">\n`;
    svg += `      <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.3"/>\n`;
    svg += `    </filter>\n`;
    svg += `  </defs>\n`;
    svg += `  <style>\n`;
    svg += `    .floor-bg { fill: #f8fafc; stroke: #e2e8f0; stroke-width: 2; }\n`;
    svg += `    .floor-title { font-family: sans-serif; font-size: 18px; font-weight: bold; fill: #1e293b; }\n`;
    svg += `    .node-router { fill: #dc2626; filter: url(#shadow); }\n`;
    svg += `    .node-mesh { fill: #2563eb; filter: url(#shadow); }\n`;
    svg += `    .device-excellent { fill: #22c55e; }\n`;
    svg += `    .device-good { fill: #84cc16; }\n`;
    svg += `    .device-fair { fill: #eab308; }\n`;
    svg += `    .device-poor { fill: #f97316; }\n`;
    svg += `    .device-critical { fill: #ef4444; }\n`;
    svg += `    .label { font-family: sans-serif; font-size: 10px; fill: #475569; }\n`;
    svg += `    .node-label { font-family: sans-serif; font-size: 12px; fill: #1e293b; font-weight: bold; }\n`;
    svg += `    .legend { font-family: sans-serif; font-size: 11px; fill: #64748b; }\n`;
    svg += `  </style>\n`;

    floors.forEach((floor, floorIndex) => {
      const yOffset = floorIndex * floorHeight;
      const nodes = Array.from(this.nodePositions.values()).filter(n => n.floorNumber === floor);
      const devices = Array.from(this.positionCache.values()).filter(p => p.floorNumber === floor);

      // Calculate bounds
      const allX = [...nodes.map(n => n.position.x), ...devices.map(d => d.position.x)];
      const allY = [...nodes.map(n => n.position.y), ...devices.map(d => d.position.y)];
      
      if (allX.length === 0) return;
      
      const minX = Math.min(...allX) - 2;
      const maxX = Math.max(...allX) + 2;
      const minY = Math.min(...allY) - 2;
      const maxY = Math.max(...allY) + 2;
      
      const scaleX = (svgWidth - 2 * padding) / Math.max(maxX - minX, 1);
      const scaleY = (floorHeight - 80 - padding) / Math.max(maxY - minY, 1);
      const scale = Math.min(scaleX, scaleY, 50); // Max 50px per meter

      const floorName = this.houseConfig?.floors.find(f => f.floorNumber === floor)?.name ?? `Etage ${floor}`;

      // Floor background
      svg += `  <rect x="10" y="${yOffset + 10}" width="${svgWidth - 20}" height="${floorHeight - 20}" rx="8" class="floor-bg"/>\n`;
      svg += `  <text x="30" y="${yOffset + 40}" class="floor-title">${floorName} (${nodes.length} Nodes, ${devices.length} Ger√§te)</text>\n`;

      // Draw grid
      const gridStartY = yOffset + 60;
      for (let x = 0; x <= maxX - minX; x += 2) {
        const px = padding + x * scale;
        svg += `  <line x1="${px}" y1="${gridStartY}" x2="${px}" y2="${gridStartY + (maxY - minY) * scale}" stroke="#e2e8f0" stroke-dasharray="2,2"/>\n`;
      }
      for (let y = 0; y <= maxY - minY; y += 2) {
        const py = gridStartY + y * scale;
        svg += `  <line x1="${padding}" y1="${py}" x2="${padding + (maxX - minX) * scale}" y2="${py}" stroke="#e2e8f0" stroke-dasharray="2,2"/>\n`;
      }

      // Draw devices
      for (const device of devices) {
        const px = padding + (device.position.x - minX) * scale;
        const py = gridStartY + (device.position.y - minY) * scale;
        const signalClass = device.confidence > 0.7 ? 'device-excellent' 
          : device.confidence > 0.5 ? 'device-good'
          : device.confidence > 0.3 ? 'device-fair'
          : device.confidence > 0.1 ? 'device-poor' : 'device-critical';
        
        svg += `  <circle cx="${px}" cy="${py}" r="6" class="${signalClass}"/>\n`;
        svg += `  <text x="${px}" y="${py + 16}" text-anchor="middle" class="label">${device.deviceName.substring(0, 15)}</text>\n`;
      }

      // Draw nodes (on top)
      for (const node of nodes) {
        const px = padding + (node.position.x - minX) * scale;
        const py = gridStartY + (node.position.y - minY) * scale;
        const nodeClass = node.nodeId === 'main' || node.nodeMac === 'main' ? 'node-router' : 'node-mesh';
        
        svg += `  <circle cx="${px}" cy="${py}" r="16" class="${nodeClass}"/>\n`;
        svg += `  <text x="${px}" y="${py + 4}" text-anchor="middle" fill="white" font-size="10" font-weight="bold">üì°</text>\n`;
        svg += `  <text x="${px}" y="${py + 30}" text-anchor="middle" class="node-label">${node.nodeId.substring(0, 12)}</text>\n`;
      }
    });

    // Legend
    const legendY = totalHeight - 30;
    svg += `  <text x="30" y="${legendY}" class="legend">Legende: </text>\n`;
    svg += `  <circle cx="100" cy="${legendY - 4}" r="8" class="node-router"/>\n`;
    svg += `  <text x="115" y="${legendY}" class="legend">Router</text>\n`;
    svg += `  <circle cx="170" cy="${legendY - 4}" r="8" class="node-mesh"/>\n`;
    svg += `  <text x="185" y="${legendY}" class="legend">Mesh Node</text>\n`;
    svg += `  <circle cx="270" cy="${legendY - 4}" r="6" class="device-excellent"/>\n`;
    svg += `  <text x="285" y="${legendY}" class="legend">Ger√§t (Farbe = Konfidenz)</text>\n`;

    svg += `</svg>`;
    return svg;
  }

  // Vector math helpers
  private rssiToDistance(rssi: number): number {
    const ratio = (this.txPower - rssi) / (10 * this.pathLossExponent);
    return Math.pow(10, ratio);
  }

  private subtract(a: Position3D, b: Position3D): Position3D {
    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
  }

  private scale(v: Position3D, s: number): Position3D {
    return { x: v.x * s, y: v.y * s, z: v.z * s };
  }

  private dot(a: Position3D, b: Position3D): number {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  }

  private cross(a: Position3D, b: Position3D): Position3D {
    return {
      x: a.y * b.z - a.z * b.y,
      y: a.z * b.x - a.x * b.z,
      z: a.x * b.y - a.y * b.x,
    };
  }

  private magnitude(v: Position3D): number {
    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
  }

  private normalize(v: Position3D): Position3D {
    const m = this.magnitude(v);
    if (m === 0) return { x: 0, y: 0, z: 0 };
    return { x: v.x / m, y: v.y / m, z: v.z / m };
  }

  private distance3D(a: Position3D, b: Position3D): number {
    return this.magnitude(this.subtract(a, b));
  }

  // Getters
  getNodePositions(): NodePlacement[] {
    return Array.from(this.nodePositions.values());
  }

  getCachedPositions(): TriangulatedPosition[] {
    return Array.from(this.positionCache.values());
  }

  clearCache(): void {
    this.positionCache.clear();
    this.signalHistory.clear();
  }

  /**
   * Export signal measurements for persistence
   */
  exportSignalMeasurements(): Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>> {
    const result: Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>> = {};
    
    for (const [deviceMac, measurements] of this.signalHistory) {
      result[deviceMac] = measurements.map(m => ({
        nodeMac: m.nodeMac,
        rssi: m.rssi,
        timestamp: m.timestamp.toISOString(),
      }));
    }
    
    return result;
  }

  /**
   * Import signal measurements from persisted state
   */
  importSignalMeasurements(data: Record<string, Array<{ nodeMac: string; rssi: number; timestamp: string }>>): void {
    for (const [deviceMac, measurements] of Object.entries(data)) {
      for (const m of measurements) {
        const nodePos = this.nodePositions.get(m.nodeMac);
        if (nodePos) {
          const history = this.signalHistory.get(deviceMac) ?? [];
          history.push({
            nodeMac: m.nodeMac,
            nodePosition: nodePos.position,
            rssi: m.rssi,
            timestamp: new Date(m.timestamp),
          });
          this.signalHistory.set(deviceMac, history);
        }
      }
    }
    
    logger.info({ deviceCount: Object.keys(data).length }, 'Signal measurements imported');
  }

  /**
   * Get signal measurement count for diagnostics
   */
  getSignalMeasurementCount(): { devices: number; measurements: number } {
    let measurements = 0;
    for (const history of this.signalHistory.values()) {
      measurements += history.length;
    }
    return { devices: this.signalHistory.size, measurements };
  }
}
